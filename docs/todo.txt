To Do
=====

To do
-----

- Push definitions out to individual modules.
- Create nice and simple boiler-plate IOC builder example.
- Common mechanism to support templates?  For example, how about `DTYP` and
`Address` attributes on classes as appropriate.
- Scan dependencies.
- Should the default startup configuration use builder style boot path?  Which
is the correct default?
- Documentation.


Functionality to extend
~~~~~~~~~~~~~~~~~~~~~~~
- Ensure that `autosave` properly implements full autosave functionality
(check wiki).
- Looks as if `calc` is a bit incomplete!
- Push `psc` from `pscBuilder/components/pscIp.py` to `psc` module.


To do later
~~~~~~~~~~~
- Parse `configure/RELEASE` to validate version consitencies.  Actually need
entirely new VERSION mechanism!
- Typo in `TimingTemplates` `decode.template`.
- Attribute lookup overrides.  When looking for 'id', first look for
'id'`\_\_`'ARCH' (where 'ARCH' is `vxWorks` or `linux_x86` etc), and when
building in simulation mode, search in order for 'id'`\_\_sim__`'ARCH',
'id'`\_\_sim`, 'id'`\_\_`'ARCH' and finally 'id'.


To maybe not do?
~~~~~~~~~~~~~~~~
- Rename `hardware` to `components`?
- Review module export mechanism.  What do we export and when?  How about
automatically exporting all `ModuleBase` classes?
- Suggestions from Austen:
. Fully commmented template build file (not quite sure what this means)
. Example `build.py` for each supported module.


Dependencies and Versions
-------------------------
Currently `Dependencies` is handled by `Device`, resulting in a variety of
actions.  It makes sense to push this up to `ModuleBase`, but abstract the
action.  Maybe override `UseModule`, and ensure that this is called in the
right sequence.

The idea would be that `UseModule` is called either just before the first time
a class is instantiated or in response to a `Dependencies` entry. 

How would this interact with `\_\_init_once\_\_`?  One quirk is that it's
possible for a class to be ``used'' without being instantiated -- would it be
correct to call `\_\_init_once\_\_` in this case?

Would it make any sense to also add `Device` type support to a support module?
The cleanest way would be to designate a dependent class which is
automatically marked as dependent.

A useful trick is to make `Dependencies` dynamic: if it is callable on first
use then invoke it before using the result.  Something like:
----
    if callable(cls.Dependencies):
        cls.Dependencies = cls.Dependencies()
----

Finally, how does this interact with `configure/RELEASE`?  It's difficult to
see how it usefully can, though.



Issues
------

Where do we manage the module globals?  Currently we have a rather tangled
approach: `\_\_init\_\_.py` defines `_globals()` to provide access to the
module globals, which is then injected into `Configure` as its private
`__globals()` method.  It also define `_add_symbol` which adds to globals and
to `_epics`.

Note that older versions of `streamProtocol` don't have `pcre`, but newer
versions require this.

Goals
-----

- Remove as much complexity as possible.
- Implement dynamic loading of modules.  Done!
- Implement outstanding TRAC requests.  Done
