Builder Architecture Notes
==========================

Goals for Current Development
-----------------------------

. Eliminate all restart functionality: builder classes are now initialised
just the once.

. Move hardware definitions into individual modules, as far as possible.

Sub-goals and issues arising
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- The `hardware` module needs to change so that it is not populated.
- What do we do about the initial default configuration?  Maybe add some
canned configure options instead.
- Let's enforce that `Configure` can only be called once.  This makes the
version file support a bit more difficult, but perhaps this is where we use
canned configurations.


Startup Processing
------------------

. Load core system modules.  This will remain unchanged.
. Import the `hardware` module and all its components.  This needs to change
rather drastically.
. The following `Configure` call:
+
    Configure(
        recordnames = BasicRecordNames(),
        iocwriter = SimpleIocWriter(),
        version = '3_14')
    Configure.LoadVersionFile('versions_3_14.py')
+
This has 'definitely' got to go!


Version Information
~~~~~~~~~~~~~~~~~~~

`version_3_14.py`

-------------------
# Version information for EPICS 3.14.8.2: static build only

SetModulePath('/dls_sw/prod/R3.14.8.2/support')
ModuleVersion('EPICS_BASE',
    home = '/dls_sw/epics/R3.14.8.2/base', use_name = False)

Configure(
    baselib = hardware.baselib.epicsBase,
    dynamic_load = False,
    register_dbd = True,
    architecture = 'vxWorks-ppc604_long')

-------------------

`version_3_13.py`

-------------------
# Version information for EPICS 3.13

SetModulePath('/home/diamond/R3.13.9/prod/support')
# Nasty hack: required for mixed build process!
ModuleVersion('EPICS_BASE',
    home = '/dls_sw/epics/R3.14.8.2/base', use_name = False)
ModuleVersion('baseTop',      '3-2')

Configure(
    baselib = hardware.baselib.iocBase,
    dynamic_load = True,
    register_dbd = False,
    architecture = 'ppc604')
-------------------

Let's take a look at what's going on here.

- First, the `SetModulePath` simply identifies where `ModuleVersion` can
locate the module definitions -- nothing too complicated here.
- Next, `ModuleVersion('EPICS_BASE',...)`.  This is a bit of a hack: we need a
module to represent the core EPICS function, and this is how it is loaded.
Perhaps we could build on this.
- Finally other aspects are configured.  Some of these could be part of the
EPICS base component, certainly the `baselib` component should.

Let's review what `Configure` does:

`recordnames`:: Specifies how record names should be specified.  A sensible
default is possible.

`iocwriter`:: Defines output hooks.  Actually this isn't really a core
configuration function, though it does affect the set of symbols exported by
the builder.

`version`::  Currently causes the appropriate `versions_%s.py` file to be
loaded, and triggers some hacks.  May be possible to eliminate this.

`baselib`:: Not quite sure: part of hooking in the EPICS base object, I think.

`dynamic_load`:: Configures whether IOCs are built with dynamic or statically
loaded libraries.  Needs to be a bit more sophisticated.  Affects the output
of the `DiamondIocWriter`, the paths to library files, and the startup script.

`architecture`:: Defines machine architecture, in particular the path to
follow in the `bin` directory.

`register_dbd`:: Whether to call `registerRecordDeviceDriver` function.  This
is an option of `dynamic_load`, only taking effect if that flag is set.


Structure of the Builder
------------------------


Class Hierarchy
~~~~~~~~~~~~~~~

`ModuleVersion`
^^^^^^^^^^^^^^^

One instance of the `ModuleVersion` class is created for each EPICS support
module being used.  The creation of this class will automatically load the
associated definitions, which are then written into the `builder.hardware`
module.

Usage: `ModuleVersion(`'module-name'`, `[`version=`'version'`, `] ['kwargs...]'`)`

'module-name'::  This must match the name of the support module directory.

'version'::  Version number of the specified module to use.  By
default the module will be loaded from 'modulePath'/'version'/'module-name'
where 'modulePath' has been specified by a call to `SetModulePath`.

`home=`'home'::  This allows the path to the support directory to be
overridden for this particular module.


`ModuleBase`
^^^^^^^^^^^^

The `ModuleBase` class provides core support for all entities based within a
module.  Each subclass will be associated with the `ModuleVersion` instance
which caused it to be loaded.  All interesting entities will be sub-classes of
this module.

The following methods are for general use:

`.LibPath()`:: Returns the full path to the module directory.

`.ModuleFile(`'filename'`)`:: Returns an absolute path to a file within this
module, raising an exeception if the file cannot be found or read.

`.ModuleVersion()`:: Returns the associated `ModuleVersion` instance.

The following method is useful for IOC generation:

`.ListModules()`:: Returns a list of all instantiated `ModuleVersion`
instances.

When creating subclasses, the following attributes can be defined:

`ModuleName`:: This defines the name of the associated `ModuleVersion`
instance, which must exist.  This field is optional: if not specified, it will
be defined equal to the subclass name unless `InheritModuleName` is set.

`InheritModuleName`:: If a subclass will be the base of a hierarchy of
subclasses, all definied within the same module, then this flag can be set.


`Substitution`: `ModuleBase`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Globals
-------

The following global state is maintained.



Modules and their exports
-------------------------

autosave.py
~~~~~~~~~~~
Support for autosave and restore.  Really needs to be written as a support
module, and should be part of the autosave device.  The main obstacle is that
it relies on hooks in the `records` class, but that can be managed.

Needs `Device` and `Substitution`, and interrogates `EpicsVersion` (though
only for a 3.13 specific hook).


bits.py
~~~~~~~
Support for bit field related records.  Depends on `records`.


configure.py
~~~~~~~~~~~~
Global configuration.  This one really needs a major rewrite -- need to
rethink the strategy for configuring the builder.  The current configuration
dance is rather painful, the following being a minimal example:

-------
from pkg_resources import require
require('dls.builder')

import dls.builder
from dls.builder import Configure

Configure(
    recordnames=dls.builder.DiamondRecordNames(),
    iocwriter=dls.builder.DiamondIocWriter)

from dls.builder import *
-------

dbd.py
~~~~~~
Loads dbd files and creates record support.  A central component of the
builder.  Depends on `mydbstatic` for the EPICS dbd interface, and subclasses
`recordbase.Record` to create individual record support.  Publishes the
globally visible `records` class which defines the set of supported record
types.

`RecordTypes`::
A collection of record types, one for each type defined in a successfully read
dbd.  Each record type is a subclass of `recordbase.Record`, which itself
ensures that all record instances are recorded by `recordset`.

`records`::
The globally published alias for `RecordTypes` -- users of the builder write
expressions such as `records.ai(\'AI_NAME\', VAL=0.3)` to create records.

`_DBD`::
Wraps the low level EPICS dbd interface provided by `mydbstatic` and
implements the `LoadDbdFile` function used to load dbd files.

`LoadDbdFile`::
An alias for `_DBD.LoadDbdFile`.  Called as part of `Device` initialisation to
read a dbd file and update the record database accordingly.  Essentially just
adds to the list of available record types.

`ValidateDbField`::
Supports record field validation using the appropriate dbd entries.

Dynamically imports `bits` for patching record definitions and
`hardware.baselib.EpicsBasePath`.


device.py
~~~~~~~~~
The core engine of the builder.  Defines the `Device` class which performs the
major lifting work that makes the builder useful.  Has the following external
dependencies:

`liblist.Hardware`::  
List of libraries and hardware entities.

`libversion.ModuleBase`::  
Base class of `Device`, links to defining module.

`dbd.LoadDbdFile`:: 
Loads dbd definitions for record support.

`configure.Configure`:: 
A number of `Configure` attributes are used:
+
`Configure.architecture`:: Path to `bin` or `lib` files.
+
`Configure.dynamic_load`:: Whether to load `bin` or `lib` files.
+
`Configure.register_dbd`:: Whether the dbd registration function needs to be
generated.

Publishes the following:

`Device`::
The big hulking monster at the centre of the builder.  Instances of
(subclasses of) this class are automatically maintained on two lists
maintained by `liblist.Hardware`: a list of all instantiated subclasses (used
to ensure that libraries are loaded), and a list of all instances (used to
generate IOC initialisation code).

`RecordFactory`::
Helper class for adding record support to devices.  Used to add the
appropriate record definitions to classes.


fanout.py
~~~~~~~~~
Exports `create_fanout` and `create_dfanout` methods, depends on `records` and
`recordbase.PP`.

hardware
~~~~~~~~
This directory currently contains all hardware implementations.  It will be
emptied out and dynamically populated by calls to `ModuleVersion`.

\_\_init\_\_.py
~~~~~~~~~~~~~~~
Top level builder initialisation.  Exports all symbols from the main modules
and performs basic initialisation of the `hardware` environment.  Currently
has some awkward interactions with `configure`.

iocinit.py
~~~~~~~~~~
Supports writing of the IOC startup script.  Uses methods `PrintBody` and
`PrintPostIocInit` provided by `liblist.Hardware` to write the startup script.

Exports quite a long list of configuration functions:

`SetTargetDir`:: Configures where the IOC picks up its startup script.
`SetEpicsPort`:: Can be used to override the default EPICS server and repeater
ports.  Equivalent to the appropriate `EpicsEnvSet` calls.
`SetGateway`:: Sets the IP address of the network gateway, if appropriate.
`SetNtpServer`:: Sets the NTP server address.
`SetEpicsLogging`:: Configures the server for EPICS logging.
`SetClockRate`:: Can be used to configure the clock rate.
`EpicsEnvSet`:: Sets an arbitrary EPICS environment variable.

Also exports `IocDataFile` which is used to package up files which need to be
copied into the built IOC.


iocwriter.py
~~~~~~~~~~~~
This provides the framework for writing the output from the builder.  This
module imports pretty well all the other modules in the builder, and publishes
the following:

`IocWriter`::  A base class for IOC writers.  Is supposed to gather all the
functionality required for generating output.
`SimpleIocWriter`:: The simplest of IOC writers, publishing methods
`WriteRecords` and `WriteHardware` which write individual files.
`DiamondIocWriter`:: A full featured IOC writer, publishing one method
`WriteIoc` which writes out an entire IOC directory.

The following resources appear to be used here:

`recordset.RecordSet.Print`
`recordset.RecordSet.PrintAutosaves`
`recordset.SubstitutionSet.Print`
`recordset.SubstitutionSet.SortedTemplateList`
`recordset.SubstitutionSet.ExpandSubstitutions`
`recordset.RecordSet.CountRecords`
`recordset.RecordSet.CountAutosaves`
`recordset.SubstitutionSet.CountSubstitutions`
`recordset.Reset`
`iocinit.iocInit.PrintIoc`
`iocinit.iocInit.AddDatabaseName`
`iocinit.IocDataFile.SetDataPath`
`iocinit.IocDataFile.CopyDataFiles`
`iocinit.IocDataFile.DataFileCount`
`iocinit.iocInit.SetIocName`
`configure.Configure.dynamic_load`
`libversion.ModuleBase.ListModules`
`hardware.Hardware.GetDbdList`
`hardware.Hardware.GetLibList`
`hardware.baselib.epicsBase.ModuleVersion`
`autosave.Autosave.SetAutosaveDir`


liblist.py
~~~~~~~~~~
Defines the `Hardware` class which manages two lists:

. List of instantiated `Device` subclasses.  This is used to ensure that the
appropriate libraries and dbd files are loaded and is interrogated by the
functions `GetDbdList` and `GetLibList`.
. List of all `Device` instances.  This is walked (together with the list
above) by the `PrintBody` and `PrintPostIocInit` methods.


libversion.py
~~~~~~~~~~~~~
Defines:
`ModuleVersion`:: 
Currently just adds the named support module to a list of known module
versions.  Will be changed to load all the support module components.
`ModuleBase`::
Base of all entities which depend on support modules.

Makes use of `Configure.EpicsVersion` for special attribute overrides, but
this can be erased.


mydbstatic.py
~~~~~~~~~~~~~
Thin `ctypes` wrapper over the EPICS dbd api.  Currently contains an absolute
path to the EPICS base libs, should be replaced by a reference to the
EPICS_BASE module (which will need to be managed as its own device).

recordbase.py
~~~~~~~~~~~~~
Implements the `Record` base class of all record instances, together with
helper functions `PP`, `CP`, `MS` and `NP` and `ImportRecord` and `Parameter`.
Depends on `recordset` for publishing records as they are instantiated.

recordnames.py
~~~~~~~~~~~~~~
Defines rules for record naming conventions.  Defines three predefined naming
conventions: `BasicRecordNames`, `TemplateRecordNames`, `DiamondRecordNames`.

recordset.py
~~~~~~~~~~~~
Defines:
`RecordSet`:: List of instantiated records.
`SubstitutionSet`:: List of instantiated subsititutions.
`Substitution`:: Used to define substitution entry.

Publishes `LookupRecord` and `Substitution`.


support.py
~~~~~~~~~~
An interesting pool of miscellaneous definitions.


versions_3_13.py, versions_3_14_6.py, versions_3_14.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Obsolescent, but the functionality defined here needs to be defined somewhere.

