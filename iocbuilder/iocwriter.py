'''The IOC writers defined here are designed to be passed to the library
Configure call as an 'iocwriter' argument.
'''

import sys, time
import os, os.path
import shutil
import types
import fnmatch

import iocinit
import recordset
import configure
import libversion
import hardware
import paths

from liblist import Hardware


__all__ = ['IocWriter', 'SimpleIocWriter', 'DiamondIocWriter']


def PrintDisclaimer(s, m=None, e=''):
    if m is None:  m = s
    now = time.strftime('%a %d %b %Y %H:%M:%S %Z')
    source = os.path.realpath(sys.argv[0])
    message = \
'''This file was automatically generated on %(now)s from
source: %(source)s

*** Please do not edit this file: edit the source file instead. ***
''' % locals()
    print s + ('\n' + m).join(message.split('\n')) + e

def PrintDisclaimerScript():
    PrintDisclaimer('# ')

def PrintDisclaimerC():
    PrintDisclaimer('/* ', ' * ', ' */')

def PrintDisclaimerCommand(cmd):
    def f():
        print '#!' + cmd
        PrintDisclaimerScript()
    return f
    

class WriteFileWrapper:
    '''A support routine for writing files using the print mechanism.  This is
    simply a wrapper around sys.stdout redirection.  Use this thus:
        output = WriteFileWrapper(filename)
        ... write to stdout using print etcetera ...
        output.Close()
    By default the standard disclaimer header is printed at the start of the
    generated file.'''

    def __init__(self, filename,
            header=PrintDisclaimerScript, maxLineLength=0):
        '''Set header=None to suppress header output.'''
        self.__stdout = sys.stdout
        self.__output = open(filename, 'w')
        self.__line = ''

        self.__maxLineLength = maxLineLength
        if self.__maxLineLength:
            sys.stdout = self
        else:
            sys.stdout = self.__output
        
        if header:
            header()

    def write(self, string):
        # Check that no line exceeds the maximum line length
        lines = string.split('\n')
        for line in lines[:-1]:
            full_line = self.__line + line
            self.__line = ''
            assert len(full_line) <= self.__maxLineLength, \
                'Line %s too long' % repr(full_line)
        self.__line = self.__line + lines[-1]
        
        self.__output.write(string)

    def Close(self):
        '''Call this to close the file being written and to restore normal
        output to stdout.'''
        assert self.__output != None, 'Close called out of sequence.'
        assert len(self.__line) <= self.__maxLineLength, \
            'Unterminated line %s too long' % repr(self.__line)
        self.__output.close()
        self.__output = None
        sys.stdout = self.__stdout


def WriteFile(filename, writer, *argv, **argk):
    output = WriteFileWrapper(filename, **argk)
    if callable(writer):
        writer(*argv)
    else:
        print writer
    output.Close()

    
class DataDirectory:
    '''Class to support the creation of data files, either dynamically
    generated inline, or copied from elsewhere.  Designed to be passed down
    to makefile building tasks.'''

    def __init__(self, ioc_root, directory):
        self.files = set()
        self.ioc_root = ioc_root
        self.directory = directory

    def Path(self, filename = None, absolute = False):
        if absolute:
            join = [self.ioc_root, self.directory]
        else:
            join = [self.directory]
        if filename is not None:
            join.append(filename)
        return os.path.join(*join)

    def __AddFilename(self, filename):
        assert '/' not in filename, 'Invalid target filename %s' % filename
        assert filename not in self.files, \
            'Filename %s already added' % filename

    def OpenFile(self, filename):
        '''Opens a new file in the target directory.'''
        self.__AddFilename(filename)
        return file(self.Path(filename, True), 'w')

    def CopyFile(self, filename, target_name=None):
        '''Copies the given file into the target directory, possibly giving
        a new name.'''
        if target_name is None:
            target_name = os.path.basename(filename)
        self.__AddFilename(target_name)
        shutil.copyfile(filename, self.Path(target_name, True))

        
class Makefile:
    '''Class to support the generation of makefiles.'''
    
    def __init__(self, path, header, footer):
        self.path = path
        self.header = header
        self.lines = []
        self.footer = footer
        self.rules = []

    def AddLine(self, *lines):
        self.lines.extend(lines)

    def AddRule(self, rule):
        self.rules.append(rule)

    def __print(self, lines):
        for line in lines:
            print line

    def Generate(self, root):
        output = WriteFileWrapper(os.path.join(root, self.path, 'Makefile'))
        self.__print(self.header)
        print
        self.__print(self.lines)
        print
        self.__print(self.footer)
        print
        self.__print(self.rules)
        output.Close()



class IocWriter:
    '''Base class for IOC writer.  A subclass of this class should be passed
    as an iocwriter option to the epics.Configure method.
        Methods are provided for access to all of the resources which define
    an IOC.
    '''

    # Some target specific maximum line lengths for the IOC shell
    IOCmaxLineLength_vxWorks = 126      # Oops
    IOCmaxLineLength_linux = 0          # EPICS shell is better behaved


    def __init__(self, iocRoot=''):
        self.iocRoot = iocRoot
        
        # Set up the appropriate methods for the actions required during IOC
        # writing.

        # Printout of records and subsititution files
        self.PrintRecords = recordset.RecordSet.Print
        self.PrintSubstitutions = recordset.RecordsSubstitutionSet.Print
        # Alternative to mass expand substitution files at build time
        self.ExpandSubstitutions = \
            recordset.RecordsSubstitutionSet.ExpandSubstitutions

        self.CountRecords = recordset.RecordSet.CountRecords
        self.CountSubstitutions = \
            recordset.RecordsSubstitutionSet.CountSubstitutions

        # Print st.cmd for IOC
        self.PrintIoc = iocinit.iocInit.PrintIoc

        # Add filename to list of databases known to this IOC
        self.AddDatabase = iocinit.iocInit.AddDatabaseName
        
        # Copies all files bound to IOC into given location
        self.SetDataPath = iocinit.IocDataSet.SetDataPath
        self.CopyDataFiles = iocinit.IocDataSet.CopyDataFiles
        self.DataFileCount = iocinit.IocDataSet.DataFileCount

        self.IOCmaxLineLength = getattr(self,
            'IOCmaxLineLength_%s' % configure.TargetOS(), 0)

        self.SetIocName = iocinit.iocInit.SetIocName


        
    def WriteFile(self, filename, writer, *argv, **argk):
        if not isinstance(filename, types.StringTypes):
            filename = os.path.join(*filename)
        WriteFile(os.path.join(self.iocRoot, filename), writer, *argv, **argk)
        

    def ResetRecords(self):
        '''This method resets only the record data but not the remaining IOC
        state.  This should only be used if incremental record creation
        without building a new IOC is required.

        It is harmless to call this method repeatedly.'''
        recordset.Reset()



class SimpleIocWriter(IocWriter):
    '''This is the simplest possible IOC writer.  Two methods are supported,
    WriteRecords and WriteHardware, which write out respectively the set of
    generated records and the IOC startup script.'''

    __all__ = ['WriteRecords', 'WriteHardware']

    def WriteRecords(self, filename):
        '''Writes all the currently generated records to the given file.
        The set of records will be reset after this has been done.  The
        filename can be specified in two parts: the filename proper is
        written to the st.cmd file, while the file is written to
        path/filename if path is given.'''
        
        # Let the IOC know about this database.
        self.AddDatabase(filename)
        # Write out the database: record set and template expansions.  In
        # this version we fully expand template instances.
        self.WriteFile(filename, self.PrintAndExpandRecords)
        # Finally reset the two resources we've just consumed.
        self.ResetRecords()

    def PrintAndExpandRecords(self):
        self.PrintRecords()
        self.ExpandSubstitutions(paths.msiPath)

    def WriteHardware(self, filename):
        '''Writes out the IOC startup command file.  The entire internal
        state (apart from configuration) is reset: this allows a new IOC
        application to be generated from scratch if required.'''

        self.WriteFile(filename, self.PrintIoc,
            maxLineLength=self.IOCmaxLineLength)



class DiamondIocWriter(IocWriter):
    '''This IOC writer generates a complete IOC application tree in the
    Diamond 3.13 style.  This should be used in the following way:

        iocWriter = OpenIocWriter(<path-to-iocs>, <domain>, <technical-area>)
        for each ioc number:
            configure ioc settings
            generate ioc definitions
            iocWriter.WriteIoc(id)
        iocWriter.Close()

    '''

    __all__ = ['WriteIoc', 'WriteNamedIoc', 'AddDataFile']
    

    IOC_configure_Skeleton = {
        'CONFIG':
'''include $(TOP)/configure/CONFIG_APP

BUILD_ARCHS = %(ARCH)s
''',

    'CONFIG_APP':
'''include $(TOP)/configure/RELEASE
-include $(TOP)/configure/RELEASE.$(EPICS_HOST_ARCH)
-include $(TOP)/configure/RELEASE.Common.$(T_A)
-include $(TOP)/configure/RELEASE.$(EPICS_HOST_ARCH).$(T_A)

CONFIG=$(EPICS_BASE)/configure
include $(CONFIG)/CONFIG
-include $(CONFIG)/CONFIG.Dls

INSTALL_LOCATION = $(TOP)
ifdef INSTALL_LOCATION_APP
INSTALL_LOCATION = $(INSTALL_LOCATION_APP)
endif

ifdef T_A
-include $(TOP)/configure/O.$(T_A)/CONFIG_APP_INCLUDE
endif

# dbst based database optimization (default: NO)
DB_OPT = NO
''',

        'Makefile':
'''TOP=..

include $(TOP)/configure/CONFIG

# Set the following to NO to disable consistency checking of
# the support applications defined in $(TOP)/configure/RELEASE
CHECK_RELEASE = %(CHECK_RELEASE)s

TARGETS = $(CONFIG_TARGETS)
CONFIGS += $(subst ../,,$(wildcard $(CONFIG_INSTALLS)))

include $(TOP)/configure/RULES
''',

        'RULES':
'''#CONFIG
-include $(CONFIG)/RULES.Dls
include  $(CONFIG)/RULES

# Library should be rebuilt because LIBOBJS may have changed.
$(LIBNAME): ../Makefile
''',

        'RULES_DIRS':
'''include $(EPICS_BASE)/configure/RULES_DIRS
''',

        'RULES.ioc':
'''include $(EPICS_BASE)/configure/RULES.ioc
''',

        'RULES_TOP':
'''include $(EPICS_BASE)/configure/RULES_TOP
''',
    }
    

    MAIN_CPP = \
'''#include "epicsExit.h"
#include "epicsThread.h"
#include "iocsh.h"

int main(int argc,char *argv[])
{
    if(argc>=2) {    
        iocsh(argv[1]);
        epicsThreadSleep(.2);
    }
    iocsh(NULL);
    epicsExit(0);
    return 0;
}
'''

    # Startup shell script for linux IOC
    LINUX_CMD = \
'''cd "$(dirname "$0")"
#    export HOME_DIR="$(cd "$(dirname "$0")"/../..; pwd)"
# cd "$HOME_DIR"
./%(ioc)s st%(ioc)s.boot'''


    # Makefile templates
    TOP_MAKEFILE_HEADER = [
        'TOP = .',
        'include $(TOP)/configure/CONFIG_APP']
    TOP_MAKEFILE_FOOTER = [
        'include $(TOP)/configure/RULES_TOP']

    MAKEFILE_HEADER = [
        'TOP = ../..',
        'include $(TOP)/configure/CONFIG']
    MAKEFILE_FOOTER = [
        'include $(TOP)/configure/RULES']


    # Directory helper routines

    def MakeDirectory(self, *dir_names):
        os.makedirs(os.path.join(self.iocRoot, *dir_names))
        
    def DeleteIocDirectory(self):
        # Checks that the newly computed iocBoot directory is a plausible IOC
        # directory.  This prevents any unfortunate accidents caused by
        # accidentially pointing at some other directory by mistake...
        #    The only files we can absolutely expect to be present are the
        # configure and iocBoot directories (as these are created by
        # __init__), and we allow for all the built directories and our App
        # directories.  Anything else is suspicious!
        dirlist = os.listdir(self.iocRoot)
        require_list = ['configure', 'iocBoot']
        ignore_list = ['bin', 'db', 'dbd', 'Makefile', 'data'] + \
            fnmatch.filter(dirlist, '%sApp' % (self.ioc_name))
        assert set(dirlist) - set(ignore_list) == set(require_list), \
            'Directory %s doesn\'t appear to be an IOC directory' % \
                self.iocRoot
        shutil.rmtree(self.iocRoot)
        

    # Published methods: alternative IOC constructors
        
    @classmethod
    def WriteIoc(cls,
            path, domain, techArea, id = 1, long_name = False, **argk):
        '''The Diamond style of IOC as supported by this writer is of the
        following form, where <ioc>=<domain>-<techArea>-IOC-<id> and <iocDir>
        is either <techArea> or <ioc> depending on whether long_name is set.
        
         <path>/<domain>/<iocDir>
           Makefile         Top level makefile to call <ioc>App Makefiles
           iocBoot/
             ioc<ioc>/      Directory for st.cmd and other ioc resources
               st<ioc>.cmd  IOC startup script
               <ioc files>  Other ioc specific files may be placed here
           <ioc>App/
             Makefile       Makefile to build IOC db directory and file
             Db/            Directory containing substitutions and other files
               <ioc>.db     Generated database file
               <ioc>.substitutions   Substitutions file
        '''
        ioc_name = '%s-%s-IOC-%02d' % (domain, techArea, id)
        if long_name:
            iocDir = ioc_name
        else:
            iocDir = techArea
        cls.WriteNamedIoc(
            os.path.join(path, domain, iocDir), ioc_name, **argk)

    @classmethod
    def WriteNamedIoc(cls, path, ioc_name, **argk):
        '''Creates an IOC in path with the specified name.'''
        cls(path, ioc_name, **argk)


    # List of files to be added to the data directory during the build.
    DataFileList = []
    
    @classmethod
    def AddDataFile(cls, filename, write_file=None):
        '''Adds a data file to the build process.  First this ensures that a
        line of the form
            DATA += filename
        appears in the <ioc>App/data/Makefile.  In turn, this line ensures
        that the named file is build (if necessary and possible) and copied to
        the top level data directory.

        Second, if write_file is given then this will be called late during
        IOC generation: this call should ensure that the necessary
        prerequisites for filename are present, and it will be passed the
        path to the data directory.'''
        cls.DataFileList.append((filename, write_file))
        

    # Top level IOC writer control

    def __init__(self, path, ioc_name,
            check_release = True, substitute_boot = False):
        # Remember parameters
        IocWriter.__init__(self, path)  # Sets up iocRoot
        self.check_release = check_release
        self.substitute_boot = substitute_boot

        # Create the working skeleton
        self.CreateIocNames(ioc_name)
        self.StartMakefiles()
        self.CreateSkeleton()

        # Actually generate the IOC
        self.GenerateIoc()

    def CreateIocNames(self, ioc_name):
        # Create the names of the important components: configure, boot, app.
        self.ioc_name = ioc_name
        iocAppDir = ioc_name + 'App'
        self.iocDbDir   = os.path.join(iocAppDir, 'Db')
        self.iocSrcDir  = os.path.join(iocAppDir, 'src')
        self.iocBootDir = os.path.join('iocBoot', 'ioc' + ioc_name)
        self.iocDataDir = os.path.join(iocAppDir, 'data')

    def StartMakefiles(self):
        header = self.MAKEFILE_HEADER
        footer = self.MAKEFILE_FOOTER
            
        self.makefile_db   = Makefile(self.iocDbDir,   header, footer)
        self.makefile_src  = Makefile(self.iocSrcDir,  header, footer)
        self.makefile_data = Makefile(self.iocDataDir, header, footer)
        self.makefile_boot = Makefile(self.iocBootDir, header, footer)
        self.makefile_top  = Makefile('',
            self.TOP_MAKEFILE_HEADER, self.TOP_MAKEFILE_FOOTER)

    def CreateSkeleton(self):
        '''Builds the complete unpopulated directory skeleton of the IOC.'''
        # Create the complete skeleton after first erasing any previous IOC
        if os.access(self.iocRoot, os.F_OK):
            self.DeleteIocDirectory()

        # The order here corresponds to the order of generation in the TOP
        # makefile.
        dirs = [
            'configure',
            self.iocDbDir,
            self.iocSrcDir,
            self.iocDataDir,
            self.iocBootDir]
        for d in dirs:
            self.MakeDirectory(d)
            self.makefile_top.AddLine('DIRS += %s' % d)

    def GenerateIoc(self):
        '''Coordinates the writing of the individual IOC components.'''
        # Push IOC name and data directory out to components that need to know
        self.SetIocName(self.ioc_name, self.substitute_boot)
        self.SetDataPath(self.iocDataDir)
        # Now tell all module base classes that IOC generation has begun.
        libversion.ModuleBase.CallModuleMethod('Finalise')

        # Generate each of the output stages.  The order matters!
        self.CreateDatabaseFiles()
        self.CreateSourceFiles()
        self.CreateBootFiles()
        self.CreateConfigureFiles()
        self.CreateDataFiles()

        # Finally generate the make files
        self.WriteMakefiles()
        
    def WriteMakefiles(self):
        '''Outputs all the individual make files.'''
        self.makefile_top.Generate(self.iocRoot)
        self.makefile_boot.Generate(self.iocRoot)
        self.makefile_data.Generate(self.iocRoot)
        self.makefile_src.Generate(self.iocRoot)
        self.makefile_db.Generate(self.iocRoot)


    # Individual stages of IOC generation
    

    def CreateDatabaseFiles(self):
        # Names of the db files we're about to build
        db = self.ioc_name + '.db'
        substitutions = self.ioc_name + '.expanded.substitutions'
        expanded = self.ioc_name + '.expanded.db'
        makefile = self.makefile_db

        makefile.AddLine('PATH := $(PATH):%s' % paths.msiPath)

        # Generate the .db and substitutions files and compute the
        # appropriate makefile targets.
        if self.CountRecords():
            self.WriteFile((self.iocDbDir, db), self.PrintRecords)
            self.AddDatabase(os.path.join('db', db))
            makefile.AddLine('DB += %s' % db)
            AutoSaveDatabaseHook(self.ioc_name, self.makefile_db, True)
        if self.CountSubstitutions():
            self.WriteFile(
                (self.iocDbDir, substitutions), self.PrintSubstitutions)
            self.AddDatabase(os.path.join('db', expanded))
            makefile.AddLine('DB += %s' % expanded)
            AutoSaveDatabaseHook(
                self.ioc_name + '.expanded', self.makefile_db, False)


    def CreateSourceFiles(self):
        makefile = self.makefile_src
        ioc = self.ioc_name
        
        makefile.AddLine('PROD_IOC = %s' % ioc)
        makefile.AddLine('DBD += %s.dbd' % ioc)
        
        for dbd_part in Hardware.GetDbdList():
            makefile.AddLine('%s_DBD += %s.dbd' % (ioc, dbd_part))
        makefile.AddLine(
            '%s_SRCS += %s_registerRecordDeviceDriver.cpp' % (ioc, ioc))
        
        # Library dependencies need to be expressed in reverse dependency
        # order so that each library pulls in the required symbols from the
        # next library loaded.
        for lib in reversed(Hardware.GetLibList()):
            makefile.AddLine('%s_LIBS += %s' % (ioc, lib))
        makefile.AddLine('%s_LIBS += $(EPICS_BASE_IOC_LIBS)' % ioc)

        # Finally add the target specific files.
        configure.Call_TargetOS(self, 'CreateSourceFiles')

    def CreateSourceFiles_linux(self):
        ioc = self.ioc_name
        self.WriteFile(
            (self.iocSrcDir, '%sMain.cpp' % ioc), self.MAIN_CPP,
            header = PrintDisclaimerC)
        self.makefile_src.AddLine('%s_SRCS += %sMain.cpp' % (ioc, ioc))

    def CreateSourceFiles_vxWorks(self):
        self.makefile_src.AddLine(
            '%s_OBJS += $(EPICS_BASE_BIN)/vxComLibrary' % self.ioc_name)


    def CreateBootFiles(self):
        extension = self.substitute_boot and 'src' or 'cmd'
        self.WriteFile(
            (self.iocBootDir, 'st%s.%s' % (self.ioc_name, extension)),
            self.PrintIoc, '../..', maxLineLength = self.IOCmaxLineLength)

        self.makefile_boot.AddLine('ARCH = %s' % configure.Architecture())
        configure.Call_TargetOS(self, 'CreateBootFiles')
        self.makefile_boot.AddLine('SCRIPTS += st%s.boot' % self.ioc_name)        
        if not self.substitute_boot:
            self.makefile_boot.AddRule(
                'envPaths cdCommands:\n'
                '\t$(PERL) $(TOOLS)/convertRelease.pl -a $(ARCH) $@')
            self.makefile_boot.AddRule('%.boot: ../%.cmd\n\tcp $< $@')
            
    def CreateBootFiles_linux(self):
        ioc = self.ioc_name
        self.WriteFile((self.iocBootDir, 'st%s.sh' % ioc),
            self.LINUX_CMD % dict(ioc = ioc),
            header = PrintDisclaimerCommand('/bin/sh'))
        if not self.substitute_boot:            
            self.makefile_boot.AddLine('SCRIPTS += envPaths')
        self.makefile_boot.AddLine('SCRIPTS += ../st%s.sh' % self.ioc_name)
        
    def CreateBootFiles_vxWorks(self):
        if not self.substitute_boot:    
            self.makefile_boot.AddLine('SCRIPTS += cdCommands')

        
    def CreateConfigureFiles(self):
        # Write the configure skeleton: mostly standard boilerplate.
        config_dict = dict(
            ARCH = configure.Architecture(),
            CHECK_RELEASE = self.check_release and 'YES' or 'NO')
        for filename, content in self.IOC_configure_Skeleton.items():
            self.WriteFile(('configure', filename), content % config_dict)

        # Write out configure/RELEASE
        releases = []
        for module in sorted(libversion.ModuleBase.ListModules()):
# Something like this might be a good idea --
#             if self.check_release:
#                 module.CheckDependencies()
            releases.append(
                '%s = %s' % (module.MacroName(), module.LibPath()))
        self.WriteFile('configure/RELEASE', '\n'.join(releases))


    def CreateDataFiles(self):
        # Note that the data files have to be generated after almost
        # everything else, as they can be generated by Initialise commands.
        self.CopyDataFiles(self.iocRoot)
        for filename, write_file in self.DataFileList:
            if write_file is not None:
                write_file(os.path.join(self.iocRoot, self.iocDataDir))
            self.makefile_data.AddLine("DATA += %s" % filename)
        


# This function is a special hack: this is called during autosave database
# generation, and is designed to be overwritten by the autosave component
# when it is created.
def AutoSaveDatabaseHook(db_name, makefile, own_records):
    pass
